/**
 * Copyright (c) 2011 - 2014 Mineground, Las Venturas Playground
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 */

package com.mineground;

import java.io.File;

import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

import com.mineground.account.AccountManager;
import com.mineground.account.PlayerLog;
import com.mineground.base.DisconnectReason;
import com.mineground.base.FeatureInitParams;
import com.mineground.base.Message;
import com.mineground.base.Settings;
import com.mineground.database.Database;
import com.mineground.features.WorldManager;
import com.mineground.remote.IrcManager;

/**
 * The Mineground class is the plugin which exposes our plugin to Bukkit. It has access to APIs for
 * most of Bukkit's internals, and decides the lifetime of the rest of the mode.
 */
public class Mineground extends JavaPlugin {
    /**
     * The core event dispatcher in use for Mineground. Consumers of any kind of event will be
     * attached as observers to the event dispatcher.
     */
    private EventDispatcher mEventDispatcher;
    
    /**
     * Class used for listening to incoming events from Bukkit, which allows Mineground to respond
     * to actions and events generated by the players on the server.
     */
    private EventListener mEventListener;
    
    /**
     * Class used for routing commands executed by the player to the feature which implements them.
     */
    private CommandManager mCommandManager;
    
    /**
     * Instance of the IRC manager, which will be responsible for connecting this Mineground server
     * to IRC, relaying information to the channel and executing commands on the server itself.
     */
    private IrcManager mIrcManager;
    
    /**
     * Class used for managing all features implemented in the Mineground plugin.
     */
    private FeatureManager mFeatureManager;
    
    /**
     * The account manager curates the accounts of all players on Mineground. Each player implicitly
     * receives an account, which they can activate by registering on the website.
     */
    private AccountManager mAccountManager;
    
    /**
     * Mineground uses a separate YML file in its data directory for configuration of this plugin.
     * The instance is writable, and will be made available to every feature. The file is stored
     * outside of the jar to avoid needing to rebuild it when a setting changes.
     */
    private FileConfiguration mConfiguration;
    private File mConfigurationFile;
    
    /**
     * Whereas the plugin's default configuration shouldn't be written to (since it would dispose of
     * all comments in the file), settings are where features can store their information.
     */
    private Settings mSettings;
    
    /**
     * Mineground stores pretty much all information (beyond the world data) in a database, ensuring
     * that it persists between sessions and can be accessed from outside this plugin as well. The
     * Database implementation is the main API for that.
     */
    private Database mDatabase;
    
    @Override
    public void onEnable() {
        // Initializes the Mineground-specific configuration (which should reside in the plugin's
        // data folder). If the data folder does not exist yet, it will be created.
        final File dataFolder = getDataFolder();
        if (!dataFolder.exists() && !dataFolder.mkdir())
            getLogger().severe("Could not create the data folder for the Mineground plugin.");
        
        mConfigurationFile = new File(dataFolder, "mineground.yml");
        mConfiguration = YamlConfiguration.loadConfiguration(mConfigurationFile);
        
        Message.SetConfiguration(mConfiguration);
        
        mSettings = new Settings(new File(dataFolder, "settings.yml"));

        // Initialize the Database API and ensure that it can connect to actual database powering
        // it. Without database access, Mineground will be significantly limited in functionality.
        mDatabase = new Database(mConfiguration, this);
        mDatabase.connect();

        PlayerLog.setDatabase(mDatabase);
        
        mAccountManager = new AccountManager(mDatabase, this);

        mEventDispatcher = new EventDispatcher();
        mEventListener = new EventListener(mEventDispatcher, mAccountManager);
        
        mCommandManager = new CommandManager(this);
        mIrcManager = new IrcManager(mConfiguration, mCommandManager, this);
        
        mCommandManager.registerCommands(mAccountManager);

        // Register |mEventListener| with Bukkit's Plugin Manager, so it will receive events.
        getServer().getPluginManager().registerEvents(mEventListener, this);

        // The Feature Manager will initialize all individual features available on Mineground,
        // which includes giving them the ability to listen for the |onMinegroundLoaded| event.
        // Features require access to a large amount of internals, passed on in FeatureInitParams.
        FeatureInitParams featureInitParams = new FeatureInitParams();
        featureInitParams.commandManager = mCommandManager;
        featureInitParams.eventDispatcher = mEventDispatcher;
        featureInitParams.configuration = mConfiguration;
        featureInitParams.database = mDatabase;
        featureInitParams.accountManager = mAccountManager;
        featureInitParams.server = getServer();
        featureInitParams.settings = mSettings;
        featureInitParams.ircManager = mIrcManager;
        
        // Instantiate the Feature Manager itself, with the parameters as we previously compiled.
        mFeatureManager = new FeatureManager(featureInitParams);
        mFeatureManager.initializeFeatures();
        
        // Tell the EventListener about objects it needs to know about, since we need to by-pass the
        // EventDispatcher in certain cases for performance reasons.
        mEventListener.setWorldManager((WorldManager) mFeatureManager.getFeature("WorldManager"));
        
        mEventDispatcher.onMinegroundLoaded();
        
        // If there are already players around on the server, we need to inform the account manager
        // and all features about them being here. Treat them as if they're just joining.
        for (Player player : getServer().getOnlinePlayers())
            mAccountManager.loadAccount(player, mEventDispatcher);
    }
    
    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] arguments) {
        return mCommandManager.onCommand(sender, command, arguments);
    }
    
    @Override
    public void onDisable() {
        // If there still are players on the server, inform the account manager and all the features
        // as if they're all leaving the server at the same time right now.
        for (Player player : getServer().getOnlinePlayers()) {
            mEventDispatcher.onPlayerDisconnect(player, DisconnectReason.SHUTDOWN);
            mAccountManager.unloadAccount(player);
        }
        
        // Fire the onMinegroundUnloaded event, telling all features that they must clean up.
        mEventDispatcher.onMinegroundUnloaded();

        // Close the database connection first, since that may depend on other instances which (at
        // this point) are still alive, and GC wise Java seems to have some trouble with that.
        mDatabase.disconnect();
        mDatabase = null;
        
        PlayerLog.setDatabase(null);
        
        // And NULL all the main instances in Mineground, which should clean up all remaining state,
        // close open connections, so that we can leave with a clear conscience.
        mFeatureManager = null;
        
        mIrcManager.disconnect();
        mIrcManager = null;

        mCommandManager = null;

        mEventListener = null;
        mEventDispatcher = null;
        
        mAccountManager = null;
        
        mSettings = null;
        
        Message.SetConfiguration(null);
        
        mConfiguration = null;
        mConfigurationFile = null;
    }
}
